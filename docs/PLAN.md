# План разработки BDUI (Backend-Driven UI) — NAHUI3

## 1. Цели и контекст

**Цель:** Система, в которой интерфейсы описываются на бэкенде (через админку), доставляются клиентам в виде файлов и отображаются нативно на iOS (SwiftUI), Android (Kotlin Compose) и Web (React).

**Текущее состояние репозитория:**
- **backend** (Go) — REST API для выдачи файлов по платформам (`/api/v1/files/{platform}`).
- **admin** (Django) — загрузка файлов интерфейсов, копирование в `files/android|ios|web`.
- **ios**, **android**, **web** — библиотеки с примитивными компонентами (пока без рендера по JSON).
- **demo** — приложения-примеры, подключающие эти библиотеки.
- **nahui3.github.io** — статический сайт документации.

**Требования из переписки:**
- Избежать тяжёлого payload (десятки МБ) и долгого парсинга на клиенте.
- Поддержать **инкрементальные обновления**: отправлять только изменённое; у каждого элемента — идентификатор и версия.
- Продумать **холодный старт**: механизм хеширования/сравнения релизов, чтобы минимизировать объём при первом запросе или при проверке обновлений.
- Ориентироваться на подход **Phoenix LiveView** (diff → patch, минимальные обновления по сети).

---

## 2. Анализ референсных репозиториев и подходов

### 2.1 DivKit (Yandex)

- **Суть:** SDUI: один JSON → рендер на Android, iOS, Web. Есть schema, json-builder (TypeScript/Kotlin/Python), клиенты под каждую платформу.
- **Полезно:** Единый формат описания UI, разделение client / schema / json-builder. Поддержка шаблонов и патчей для динамических обновлений.
- **Учёт:** Взять идею единой схемы и платформо-специфичных рендереров; формат наших «экранов» можно сделать совместимым по духу (контейнеры, текст, картинка, список и т.д.).

### 2.2 bdui-demo (TOPOFGR)

- **Суть:** Упрощённый Backend-Driven UI: NestJS отдаёт «шаблоны/вью», Next.js рендерит страницы на основе ответов бэкенда.
- **Полезно:** Разделение backend (ui-api) и frontend (my-web), одна точка входа для разных представлений.
- **Учёт:** Наша админка — источник «описаний экранов»; backend — доставка; клиенты (ios/android/web) — потребители описаний.

### 2.3 assimelha/bdui, nmelo/bdui

- **Суть:** TUI/Web UI для трекера beads (bd), не про формат BDUI-интерфейсов.
- **Учёт:** Не переносим архитектуру, но идея «клиент получает данные и рендерит по единому описанию» совпадает с нашей.

### 2.4 BDUIKnit (bdaralan), blooblahguy/bdUI

- **Суть:** Переиспользуемые UI-компоненты (SwiftUI) и аддоны для игр — не про серверный драйв интерфейса.
- **Учёт:** Не меняет план; библиотеки ios/android/web у нас как раз «кирпичики» для рендера серверного описания.

### 2.5 Phoenix LiveView

- **Суть:** Сервер держит состояние, при событиях перерисовывает шаблон и шлёт клиенту **только diff**; клиент применяет patch к DOM. Первый рендер — обычный HTML (быстрый FMP).
- **Полезно:** Идентификация узлов (в т.ч. по id), diff по дереву, минимальный трафик. Temporary assigns и stream — для больших списков без пересылки всего.
- **Учёт:** Ввести у каждого узла UI **стабильный id** и **version** (или content-hash). На клиенте хранить текущее дерево; при обновлении получать diff (или полный экран с версиями) и мержить/патчить только изменённые поддеревья.

### 2.6 Hotwire / Turbo

- **Суть:** Turbo Frames + Streams; morph (idiomorph) — обновление только изменённых частей страницы без полной перезагрузки.
- **Полезно:** Подход «только изменённые фрагменты» и идентификация по id.
- **Учёт:** Аналогия: наш «экран» = документ с id-узлами; обновление = набор патчей по id (или delta-операции add/remove/update).

### 2.7 Blazor Server, Liveview (Elixir), StimulusReflex, Sockpuppet

- **Общее:** Серверное состояние, обновления по диффу/командам по сети (WebSocket/SSE), минимум данных на клиент.
- **Учёт:** Для мобильных и веба не обязательно держать постоянный WebSocket; достаточно: «запрос экрана по id/версии → ответ полный или delta». Хеши/версии на уровне экрана и узлов дают возможность отдавать delta при повторных запросах.

---

## 3. Проблемы и решения

| Проблема | Решение |
|----------|--------|
| Огромный JSON, долгий парсинг | 1) Отдавать только изменённые узлы (delta). 2) У каждого узла `id` + `version` (или content-hash). 3) Разбивать экран на блоки/секции с отдельными версиями. |
| Долгий холодный старт | 1) На клиенте хранить последний известный «релиз» (например, hash экрана или manifest с хешами блоков). 2) При старте: `GET /api/v1/screen/{id}?client_hash=...`; если hash совпадает — 304 или пустой delta. 3) Иначе — полный экран или delta от известной серверу версии. 4) По возможности — приоритет критичного «above the fold» контента (первый chunk). |
| Сравнение релизов | Единый **manifest** на экран/приложение: список блоков (или узлов верхнего уровня) с `id` и `hash`. Клиент прикладывает свой manifest/hash; сервер решает: full payload или delta. |
| Консистентность формата | Единая **схема** (JSON Schema) описания экрана и узлов; валидация в админке при загрузке/редактировании; генерация типов/моделей для ios/android/web (по аналогии с DivKit api_generator). |

---

## 4. Общая архитектура

```
┌─────────────────┐     загрузка/редактирование      ┌──────────────────┐
│  Admin (Django)  │ ────────────────────────────────► │  Хранилище       │
│  админка BDUI   │                                   │  (files + meta)  │
└─────────────────┘                                   └────────┬─────────┘
                                                               │
                        ┌──────────────────────────────────────┼──────────────────────────────────────┐
                        │  Backend (Go)                         │                                      │
                        │  - REST: экраны, manifest, delta      │                                      │
                        │  - Версионирование, хеши, delta       │                                      │
                        └──────────────────┬───────────────────┘                                      │
                                           │                                                                 │
              GET /screens, /screen/:id?client_hash=...  GET /files/{platform} (legacy/статика)           │
              GET /manifest, /delta?...                                                                       │
                        │                                                                                     │
        ┌────────────────┼────────────────┐                                                                 │
        ▼                ▼                ▼                                                                  │
┌───────────────┐ ┌───────────────┐ ┌───────────────┐                                                        │
│  iOS (SwiftUI)│ │ Android       │ │  Web (React)  │  ◄── Библиотеки рендера по единому формату              │
│  NAHUI        │ │ Compose       │ │  @nahui3/web  │      (из папок ios / android / web)                    │
└───────────────┘ └───────────────┘ └───────────────┘                                                        │
```

**Формат описания экрана (концепт):**
- Дерево узлов. Каждый узел: `id`, `version` (или `hash`), `type` (container, text, image, list, ...), `props`, `children`.
- Manifest: список `{ id, version/hash }` для корневых блоков или ключевых узлов.
- Delta: массив операций `{ op: "add"|"update"|"remove", id, version, payload? }` или патч по id.

**Потоки:**
1. **Холодный старт:** клиент без кеша → запрос экрана (или manifest) → сервер отдаёт полное дерево + manifest; клиент кеширует и рендерит.
2. **Проверка обновлений:** клиент шлёт `client_manifest` (id+version); сервер сравнивает, отдаёт delta или 304.
3. **Админка:** публикация нового «релиза» пересчитывает версии/хеши и сохраняет артефакты в хранилище (файлы + индекс в БД или файловый manifest).

---

## 5. Разбивка по папкам (7 направлений)

Ниже — план по семи корневым папкам репозитория: **admin**, **android**, **backend**, **demo**, **ios**, **nahui3.github.io**, **web**.

---

### 5.1 admin

**Назначение:** Управление контентом BDUI: экраны, версии, валидация схемы, публикация.

**Задачи:**

1. **Модели и хранение**
   - Расширить или ввести модели под «экраны» BDUI (Screen/Release), а не только сырые файлы: название, платформа (или общий), версия, связь с файлом(ами) и метаданными (manifest, hash).
   - Хранить manifest (id + version/hash узлов) для каждого опубликованного релиза; при сохранении пересчитывать хеши от содержимого.

2. **Валидация и схема**
   - Принять единую JSON Schema для формата экрана (дерево узлов с `id`, `version`, `type`, `props`, `children`).
   - При загрузке/редактировании экрана валидировать JSON по схеме (например, через jsonschema в Python).
   - Опционально: визуальный редактор или превью (iframe с web-рендером) по аналогии с bdui-demo.

3. **Публикация и синхронизация с backend**
   - При публикации экрана: генерировать/обновлять manifest, пересчитывать хеши, сохранять артефакты в общую директорию `files/` (или в подпапки по платформам/экранам), чтобы backend мог отдавать их по API.
   - Сохранять историю версий (хотя бы последняя N версий) для возможности delta между версиями.

4. **Интеграция с файлами**
   - Оставить текущий поток загрузки файлов (InterfaceFile) для обратной совместимости; новый поток — «экраны BDUI» с версионированием и manifest. При необходимости копировать сгенерированные JSON в `files/android|ios|web` в формате, ожидаемом backend.

**Результат:** Админка — единственная точка ввода/редактирования экранов и источник правды для manifest и версий.

---

### 5.2 backend

**Назначение:** API доставки экранов, manifest и delta; поддержка условной отдачи по хешу/версии клиента.

**Задачи:**

1. **Новые эндпоинты**
   - `GET /api/v1/screens` — список экранов (id, название, последняя версия/hash).
   - `GET /api/v1/screens/:id` — полное описание экрана (дерево узлов). Query: `?platform=android|ios|web` при необходимости платформо-специфичного контента.
   - `GET /api/v1/screens/:id/manifest` — manifest экрана (список id + version/hash).
   - `GET /api/v1/screens/:id/payload?client_hash=...` или `GET /api/v1/screens/:id/delta?client_manifest=...` — полный payload или delta. Если `client_hash` совпадает с текущим — 304 Not Modified или пустой JSON; иначе — полное дерево или массив delta-операций.

2. **Логика версий и delta**
   - Читать из хранилища (файлы, сгенерированные админкой) текущий экран и его manifest.
   - Реализовать сравнение по `client_manifest`: какие узлы изменились (version/hash), формировать delta (add/update/remove) или отдавать полный экран при несовместимой/старой версии клиента.
   - Поддержать «холодный старт» без query — отдавать полный экран + manifest.

3. **Хранение и структура файлов**
   - Договориться со структурой в `files/`: например `files/screens/{screen_id}/v{version}.json`, `files/screens/{screen_id}/manifest.json`; или по платформам `files/{platform}/screens/{id}.json` с метаданными в отдельном файле. Реализовать чтение этих артефактов в Go.

4. **Обратная совместимость**
   - Сохранить текущие `GET /api/v1/files`, `GET /api/v1/files/{platform}`, `GET /api/v1/files/{platform}/{filename}` для статичных файлов и существующих клиентов.

**Результат:** Клиенты получают экраны по id, проверяют обновления по hash/manifest и при необходимости запрашивают только delta.

---

### 5.3 ios

**Назначение:** Библиотека рендера BDUI на SwiftUI: парсинг формата (дерево узлов), маппинг типов в SwiftUI-вью, применение delta.

**Задачи:**

1. **Модели данных**
   - Модели узлов по единой схеме: `id`, `version`, `type`, `props`, `children`; типы Container, Text, Image, List, Input и т.д. (Codable из JSON).

2. **Рендер по типу**
   - Для каждого `type` — соответствующая SwiftUI View (аналог DivKit client). Использовать/расширять существующие компоненты (например, SimpleTextFieldView) как примитивы.

3. **Дерево и обновления**
   - Хранить текущее дерево экрана в памяти; при получении полного payload — заменить; при получении delta — применить add/update/remove по `id` (рекурсивно по детям при необходимости).

4. **Сеть и кеш**
   - Клиентский API: загрузка экрана по id, опционально передача `client_hash` или `client_manifest`; разбор ответа (full vs delta), применение и перерисовка. Локальный кеш последнего экрана + manifest для офлайна и быстрого старта.

5. **Документация и тесты**
   - README и примеры использования в demo; юнит-тесты парсинга и применения delta.

**Результат:** iOS-приложение (demo) подключает библиотеку, запрашивает экран у backend и отображает его; при обновлениях получает delta и обновляет только изменённые узлы.

---

### 5.4 android

**Назначение:** Библиотека рендера BDUI на Kotlin Compose: те же контракты (дерево узлов, id, version, type, props, children), применение delta.

**Задачи:**

1. **Модели данных**
   - data-классы или сериализация (например, kotlinx.serialization) для узлов по общей схеме; типы контейнер, текст, картинка, список, поле ввода и т.д.

2. **Рендер по типу**
   - Для каждого типа — Composable (аналог DivKit client). Переиспользовать FieldWithText и другие существующие компоненты.

3. **Дерево и обновления**
   - Состояние текущего дерева; применение full payload или delta (add/update/remove по id).

4. **Сеть и кеш**
   - HTTP-клиент для запросов экрана/delta с `client_hash`/manifest; кеш последнего экрана и manifest.

5. **Документация и тесты**
   - Обновить docs/USAGE.md; пример в demo; тесты парсинга и delta.

**Результат:** Android demo запрашивает экран, рендерит его в Compose и обновляется по delta.

---

### 5.5 web

**Назначение:** React-библиотека рендера BDUI: тот же формат дерева, компоненты по типам, применение delta на виртуальном дереве и обновление React-состояния.

**Задачи:**

1. **Модели и типы**
   - TypeScript-типы/интерфейсы для узлов (id, version, type, props, children); общая схема в виде типов или импорт из единой схемы (JSON Schema → типы).

2. **Рендер по типу**
   - Маппинг type → React-компонент (контейнер, текст, картинка, список, инпут). Использовать HelloNahui и другие примитивы как базу.

3. **Дерево и обновления**
   - Хранить дерево в state (например, useState/useReducer); при full payload — setState(tree); при delta — функция applyDelta(tree, delta) и setState(newTree). Рекурсивное обновление по id.

4. **Сеть и кеш**
   - Хук или сервис: fetch screen by id, опционально client_hash/client_manifest; разбор full vs delta; кеш в памяти или localStorage для быстрого повторного отображения.

5. **Сборка и экспорт**
   - Публичный API: компонент `<BDUIScreen screenId="..." />` или `<BDUIRenderer tree={...} />`, плюс хук для загрузки с backend. Документация в docs/.

**Результат:** Web demo загружает экран с backend и рендерит его; обновления через delta без полной перезагрузки дерева.

---

### 5.6 demo

**Назначение:** Демонстрация полного цикла: загрузка экрана с backend, отображение на каждой платформе, проверка обновлений и delta.

**Задачи:**

1. **Общая настройка**
   - Указать URL backend (конфиг или env); экран по умолчанию (например, один тестовый screen_id).

2. **demo/android**
   - Подключить библиотеку android; экран с кнопкой «Загрузить экран» и областью рендера; при старте запрашивать экран, при обновлении — показывать применение delta (логи или визуально).

3. **demo/ios**
   - Подключить NAHUI; экран загрузки по id, отображение дерева BDUI; опционально pull-to-refresh с запросом delta по текущему manifest.

4. **demo/web**
   - Страница с выбором экрана (или один фиксированный); загрузка через хук, рендер через компонент библиотеки web; кнопка «Проверить обновления» с передачей client_hash и отображением результата (full/delta).

5. **Тестовые данные**
   - В админке создать 1–2 тестовых экрана с разными типами узлов; убедиться, что backend отдаёт их, а все три демо их показывают и корректно обрабатывают delta после изменения в админке.

**Результат:** Один и тот же экран, описанный в админке, отображается в demo на iOS, Android и Web и обновляется по delta при изменениях.

---

### 5.7 nahui3.github.io

**Назначение:** Документация проекта и BDUI: описание архитектуры, формата экрана, API backend, использования библиотек.

**Задачи:**

1. **Контент**
   - Страница/раздел «BDUI»: обзор архитектуры (админка → backend → клиенты), схема формата экрана (id, version, type, props, children), пример JSON.
   - Описание API: `GET /api/v1/screens`, `GET /api/v1/screens/:id`, manifest, delta, query-параметры `client_hash`/`client_manifest`.
   - Краткие инструкции по использованию библиотек ios/android/web для рендера экрана и проверки обновлений.

2. **Ссылки**
   - Обновить список репозиториев и ссылки на backend, admin, ios, android, web, demo; при необходимости добавить раздел «Референсы» (DivKit, LiveView, Turbo).

3. **Единообразие**
   - Стили и навигация в соответствии с текущим index.html/styles.css.

**Результат:** Разработчики и продукт могут прочитать на сайте, как устроен BDUI, какой формат и API использовать и как интегрировать библиотеки.

---

## 6. Порядок реализации (предложение)

1. **Схема и формат** — зафиксировать JSON Schema экрана (дерево узлов, id, version, type, props, children) в репозитории (например, в backend или в отдельной папке `schema/` в корне).
2. **backend** — реализовать хранение экранов (файлы + manifest), эндпоинты screens, manifest, payload с поддержкой `client_hash` и простой delta (например, сначала только full payload при разном hash).
3. **admin** — модели экранов, валидация по схеме, публикация с записью manifest и файлов в структуру, ожидаемую backend.
4. **web** — модели, рендер по типам, загрузка экрана, затем поддержка delta в state. Быстрее всего для итерации и отладки с backend.
5. **ios** и **android** — параллельно: модели, рендер, загрузка, применение delta.
6. **demo** — свести все три платформы к одному сценарию загрузки и обновления.
7. **nahui3.github.io** — обновить документацию по BDUI и API.

---

## 7. Риски и смягчение

| Риск | Смягчение |
|------|------------|
| Схема формата будет часто меняться | Версионировать схему (например, `schema_version: 1` в корне экрана); backend и клиенты поддерживают несколько версий или отказ при несовместимости. |
| Delta сложно реализовать одинаково на трёх платформах | Спека delta в виде массива операций (add/update/remove по id) в JSON; единые тест-кейсы (fixtures) для применения delta. |
| Холодный старт всё равно тяжёлый для очень больших экранов | Разбивать экран на «блоки» с отдельными manifest и lazy-загрузкой блоков ниже fold; приоритет первого блока. |

---

## 8. Краткая сводка по папкам

| Папка | Фокус |
|-------|--------|
| **admin** | Модели экранов, валидация схемы, публикация с manifest/хешами, синхронизация с backend. |
| **backend** | API screens/manifest/delta, логика версий и client_hash, хранение артефактов из админки. |
| **ios** | Модели, рендер по типам, применение delta, сеть и кеш. |
| **android** | Модели, рендер по типам, применение delta, сеть и кеш. |
| **web** | Типы, рендер по типам, применение delta, хуки загрузки и кеш. |
| **demo** | Интеграция всех трёх платформ с одним backend и сценарием full/delta. |
| **nahui3.github.io** | Документация BDUI: архитектура, формат, API, использование библиотек. |

Этот план можно использовать как единый .md-файл для обсуждения и последующей разбивки на тикеты/задачи по репозиториям.
