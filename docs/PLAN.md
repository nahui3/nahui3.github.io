# План разработки BDUI (Backend-Driven UI) — NAHUI3

## 1. Цели и контекст

**Цель:** Система, в которой интерфейсы описываются на бэкенде (через админку), доставляются клиентам в виде файлов и отображаются нативно на iOS (SwiftUI), Android (Kotlin Compose) и Web (React).

**Текущее состояние репозитория:**
- **backend** (Go) — REST API для выдачи файлов по платформам (`/api/v1/files/{platform}`).
- **admin** (Django) — загрузка файлов интерфейсов, копирование в `files/android|ios|web`.
- **ios**, **android**, **web** — библиотеки с примитивными компонентами (пока без рендера по JSON).
- **demo** — приложения-примеры, подключающие эти библиотеки.
- **nahui3.github.io** — статический сайт документации.

**Требования из переписки:**
- Избежать тяжёлого payload (десятки МБ) и долгого парсинга на клиенте.
- Поддержать **инкрементальные обновления**: отправлять только изменённое; у каждого элемента — идентификатор и версия.
- Продумать **холодный старт**: механизм хеширования/сравнения релизов, чтобы минимизировать объём при первом запросе или при проверке обновлений.
- Ориентироваться на подход **Phoenix LiveView** (diff → patch, минимальные обновления по сети).

---

## 2. Анализ референсных репозиториев и подходов

### 2.1 DivKit (Yandex)

- **Суть:** SDUI: один JSON → рендер на Android, iOS, Web. Есть schema, json-builder (TypeScript/Kotlin/Python), клиенты под каждую платформу.
- **Полезно:** Единый формат описания UI, разделение client / schema / json-builder. Поддержка шаблонов и патчей для динамических обновлений.
- **Учёт:** Взять идею единой схемы и платформо-специфичных рендереров; формат наших «экранов» можно сделать совместимым по духу (контейнеры, текст, картинка, список и т.д.).

### 2.2 bdui-demo (TOPOFGR)

- **Суть:** Упрощённый Backend-Driven UI: NestJS отдаёт «шаблоны/вью», Next.js рендерит страницы на основе ответов бэкенда.
- **Полезно:** Разделение backend (ui-api) и frontend (my-web), одна точка входа для разных представлений.
- **Учёт:** Наша админка — источник «описаний экранов»; backend — доставка; клиенты (ios/android/web) — потребители описаний.

### 2.3 assimelha/bdui, nmelo/bdui

- **Суть:** TUI/Web UI для трекера beads (bd), не про формат BDUI-интерфейсов.
- **Учёт:** Не переносим архитектуру, но идея «клиент получает данные и рендерит по единому описанию» совпадает с нашей.

### 2.4 BDUIKnit (bdaralan), blooblahguy/bdUI

- **Суть:** Переиспользуемые UI-компоненты (SwiftUI) и аддоны для игр — не про серверный драйв интерфейса.
- **Учёт:** Не меняет план; библиотеки ios/android/web у нас как раз «кирпичики» для рендера серверного описания.

### 2.5 Phoenix LiveView

- **Суть:** Сервер держит состояние, при событиях перерисовывает шаблон и шлёт клиенту **только diff**; клиент применяет patch к DOM. Первый рендер — обычный HTML (быстрый FMP).
- **Полезно:** Идентификация узлов (в т.ч. по id), diff по дереву, минимальный трафик. Temporary assigns и stream — для больших списков без пересылки всего.
- **Учёт:** Ввести у каждого узла UI **стабильный id** и **version** (или content-hash). На клиенте хранить текущее дерево; при обновлении получать diff (или полный экран с версиями) и мержить/патчить только изменённые поддеревья.

### 2.6 Hotwire / Turbo

- **Суть:** Turbo Frames + Streams; morph (idiomorph) — обновление только изменённых частей страницы без полной перезагрузки.
- **Полезно:** Подход «только изменённые фрагменты» и идентификация по id.
- **Учёт:** Аналогия: наш «экран» = документ с id-узлами; обновление = набор патчей по id (или delta-операции add/remove/update).

### 2.7 Blazor Server, Liveview (Elixir), StimulusReflex, Sockpuppet

- **Общее:** Серверное состояние, обновления по диффу/командам по сети (WebSocket/SSE), минимум данных на клиент.
- **Учёт:** Для мобильных и веба не обязательно держать постоянный WebSocket; достаточно: «запрос экрана по id/версии → ответ полный или delta». Хеши/версии на уровне экрана и узлов дают возможность отдавать delta при повторных запросах.

---

## 3. Проблемы и решения

| Проблема | Решение |
|----------|--------|
| Огромный JSON, долгий парсинг | - Отдавать только изменённые узлы (delta). |
| | - Будем использовать **content-hash** для определения изменений. |
| Долгий холодный старт | - Будем хранить **hash файла** с кодом экрана или компонента экрана. |
| | - На клиенте хранить последний известный релиз; при старте передавать версию; при совпадении — 304 или пустой delta; иначе — полный набор файлов фичи или delta. |
| Сравнение релизов | - Будем использовать **манифест на всё приложение** для определённой платформы. |
| | - Минимальной единицей будет файл с экраном или элементом экрана. |
| | - В манифесте отображается версия приложения на соответствующей платформе. |
| Консистентность формата и версионирование | - На бэкенде в CI/CD — **воркер**, который периодически анализирует указанную в настройках админки ветку проекта и на основе входящих в ветку файлов строит дерево хешей и манифесты, версионирует их. |
| | - В админке можно посмотреть любую версию для каждой платформы и указать, какую версию нужно накатить. |
| | - Когда клиент обращается и передаёт номер версии, сервер сравнивает её с той, которую нужно накатить, и готовит дельты изменений (и сохраняет их в кеше, если их там не было). |
| | - Когда в кеше есть нужные дельты — клиент, обращаясь к конкретному экрану (фиче), может получить дельту по нему или ответ, что изменений не было. |

---

## 4. Общая архитектура

```
┌─────────────────┐     настройки, выбор версии       ┌──────────────────┐
│  Admin (Django)  │ ────────────────────────────────► │  Хранилище       │
│  админка BDUI   │     CI/CD воркер → манифесты       │  (.git + files)  │
└─────────────────┘                                   └────────┬─────────┘
                                                               │
                        ┌──────────────────────────────────────┼──────────────────────────────────────┐
                        │  Backend (Go)                         │                                      │
                        │  - REST: фичи, манифесты, дельты     │                                      │
                        │  - Сравнение версий, кеш дельт       │                                      │
                        └──────────────────┬───────────────────┘                                      │
                                           │                                                              │
              GET /feature/:id?platform=...&client_version=...  GET /files/{platform} (legacy)          │
                        │                                                                                │
        ┌────────────────┼────────────────┐                                                              │
        ▼                ▼                ▼                                                              │
┌───────────────┐ ┌───────────────┐ ┌───────────────┐                                                   │
│  iOS          │ │  Android      │ │  Web          │  ◄── Библиотеки рендера по манифесту и файлам     │
│  SwiftUI      │ │  Kotlin       │ │  React        │      (SPM nahui3 / Compose nahui3 / компонент nahui3)│
│  SPM nahui3   │ │  Compose      │ │  nahui3       │                                                   │
└───────────────┘ │  nahui3       │ └───────────────┘                                                   │
                  └───────────────┘                                                                       │
```

**Фича** — небольшой проект со своим манифестом и набором файлов-узлов (обычно фича соответствует экрану). Также есть корневая фича, которая описывает набор всех фич в аналогичном виде.

**Узел (файл в фиче):**
- **id** — UUID, производный от пути к файлу в проекте.
- **name** - имя файла
- **hash** - хеш файла (content-hash).
- Вся иерархия задаётся манифестом.

**Манифест:**
- Описывает дерево папок и файлов фичи с дополнительной информацией (id, имя, хеш для каждого файла-узла).
- Формат: XML, JSON, YAML или другой, подходящий для задачи.
- Манифест на всё приложение для данной платформы включает версию приложения на этой платформе.

**Дельта:**
- Строится **сервером** при сравнении версии клиента и версии, опубликованной через админку.
- Хранится **только в кешах сервера**; клиент получает уже готовую дельту по запросу (по фиче/экрану).

**Потоки:**
1. **Холодный старт:** клиент передаёт версию и идентификатор фичи → на сервере достаётся манифест 2х версий (переданной и опубликованной), они сравниваются и сервер строит дельту, помещает её в кеш и отправляет клиенту вместе с опубликованным манифестом → клиент применяет дельту, кеширует манифест и рендерит.
2. **Проверка обновлений:** клиент передаёт версию и идентификатор фичи → сервер ищет в кеше дельты между переданной версией и опубликованной, достаёт из кеша дельты, отдаёт дельту вместе с опубликованным манифестом → клиент применяет дельту к предыдущему манифесту, кеширует новый манифест и рендерит.
3. **Админка и CI/CD:** воркер анализирует ветку проекта, строит дерево хешей и манифесты, версионирует их; в админке выбирают версию для наката по платформам.

---

## 5. Разбивка по папкам (7 направлений)

Детальные планы по каждому направлению вынесены в отдельные файлы в папке **[plan/](plan/)**:

- [plan/admin.md](plan/admin.md) — админка
- [plan/backend.md](plan/backend.md) — бэкенд
- [plan/ios.md](plan/ios.md) — iOS (SwiftUI SPM-пакет nahui3)
- [plan/android.md](plan/android.md) — Android (Kotlin Compose библиотека nahui3)
- [plan/web.md](plan/web.md) — Web (React-компонент nahui3)
- [plan/demo.md](plan/demo.md) — демо-приложения
- [plan/nahui3.github.io.md](plan/nahui3.github.io.md) — документация

---

## 6. Порядок реализации (предложение)

1. **Манифесты по фичам** — манифест по каждой фиче отдельно для каждого направления (ios/android/web). Манифест соответствует файловой структуре в фиче. Формат манифеста — XML, JSON, YAML или другой, подходящий для задачи. Манифесты должны версионироваться (отдельный .git-репозиторий или подпапка в backend).
2. **backend** — реализовать хранение фич и манифестов (в т.ч. из .git), CI/CD-воркер для построения дерева хешей и манифестов, эндпоинты для фич и дельт с поддержкой версии клиента и кешированием дельт.
3. **admin** — настройки ветки проекта для воркера, просмотр версий по платформам, выбор версии для наката.
4. **web** — загрузка фичи по id, передача версии платформы, применение дельты от сервера; быстрее всего для итерации с backend.
5. **ios** и **android** — параллельно: загрузка фичи, передача версии, применение дельты, рендер по манифесту и файлам.
6. **demo** — свести все три платформы к одному сценарию: запрос фичи с версией, отображение, проверка обновлений (дельта).
7. **nahui3.github.io** — обновить документацию по BDUI: архитектура, фичи и манифесты, API, использование библиотек nahui3.

---

## 7. Риски и смягчение

| Риск | Смягчение |
|------|------------|
| Схема формата будет часто меняться | Схема не планируется часто менять; на всякий случай ввести версию схемы. Меняться будет только наполнение манифестов — оно соответствует файловой структуре фичи и входящих в неё файлов с хешами. Есть корневая фича, в которой прописаны остальные фичи и их расположение в файлах. Сами манифесты версионируются на сервере внутри .git-репозитория. |
| Delta и согласованность клиент/сервер | Есть версия на клиенте и опубликованная версия на сервере. Клиент отправляет номер версии платформы и название/ID фичи, которую смотрит. Сервер достаёт соответствующий манифест, сравнивает с опубликованным манифестом, строит дельту (или достаёт из кеша), сохраняет её в кеш и отправляет манифест и дельту клиенту; клиент применяет дельту и кеширует манифест. |
| Холодный старт и размер payload | Манифест корневой фичи и манифесты отдельных фич (фича обычно соответствует экрану) весят мало. На клиент отправляются только дельты по конкретной фиче, а не весь набор файлов приложения. |
| | |

---

## 8. Краткая сводка по папкам

| Папка | Фокус |
|-------|--------|
| **admin** | Настройки ветки проекта для CI/CD-воркера, просмотр версий по платформам, выбор версии для наката. |
| **backend** | CI/CD-воркер (дерево хешей, манифесты, версионирование), API фич и дельт, сравнение версий клиента и накатанной, кеш дельт. |
| **ios** | SwiftUI SPM-пакет nahui3: загрузка фичи, передача версии, применение дельты, рендер. |
| **android** | Kotlin Compose библиотека nahui3: загрузка фичи, передача версии, применение дельты, рендер. |
| **web** | React-компонент nahui3: загрузка фичи, передача версии, применение дельты, рендер. |
| **demo** | Интеграция всех трёх платформ с одним backend: запрос фичи с версией, отображение, проверка обновлений (дельта). |
| **nahui3.github.io** | Документация BDUI: архитектура, фичи и манифесты, API, использование библиотек nahui3. |

Этот план можно использовать как единый .md-файл для обсуждения и последующей разбивки на тикеты/задачи по репозиториям.
